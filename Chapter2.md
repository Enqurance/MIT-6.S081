# MIT 6.S081 Chapter2

本章主要介绍操作系统的组织结构，介绍了操作系统的一些抽象设计，对一些抽象的层次进行了简单的描述。首先，我们需要指出操作系统需要支持的三大特性，分别是并发性、隔离性、共享性。并发性是指，操作系统中的不同人物都有机会使用操作系统抽象出的资源，包括CPU、内存、磁盘、外设等。隔离性是指，操作系统中不同的任务在自己的视角下，能够独享资源服务，不受其他任务的影响。而共享性则是指，操作系统的不同任务之间能够沟通交流，共同完成用户请求。为了打成这些目的，操作系统需要实现一些必要的设计。

## 2.1 抽象物理资源

如果计算机中的每一个任务都能够直接通过某种方式访问物理资源，那么可能会导致非常混乱的结果。譬如，有的任务可能占着资源不放手，有的任务可能不小心访问了其他任务的资源，有的任务可能发生错误而直接破坏物理资源......为了尽可能避免这些情况的发生，人们让操作系统抽象并管理这些物理资源，合理调度分配给各个任务，并且向任务隔离敏感的物理资源，防止任务出错而导致的严重后果。譬如`read`、`write`这类系统调用，就抽象了磁盘资源，操作系统收到了任务的读写请求，并且自己来操作磁盘完成这些请求，由于操作系统是精心设计的，我们可以大胆地认为在一般情况下任务的这些请求都是安全的（不管他们最后是否被成功执行了）。除此之外，还有许多种不同资源的抽象和不同的抽象方式，这些设计在不同的操作系统当中有一些区别，但他们的目的都是相同的。

## 2.2 用户模式、管理员模式和系统调用

为了实现隔离性，操作系统需要“保护”自己，将自身与可能修改操作系统的程序和行为隔离开来。因此，我们需要想办法限制应用程序的权限。一个比较理想的方案就是分发不同的权限模式，对核心功能进行保护。

CPU自身对硬件资源就提供了很好的隔离方案。譬如，RISC-V架构的CPU支持用户模式、管理员模式和机器模式。在不同的模式下，机器能够执行不同的指令。用户模式下的应用程序能够执行一些普通的指令，如普通的运算、跳转等指令，且只能在用户空间中运行；而管理员模式下，机器可以执行更高权限的指令（包括开关中断的指令），而一般在管理员模式下执行的程序，运行在内核空间，我们将这些程序称为内核。

若运行在用户空间的应用程序需要一些内核指令来完成任务，那么就需要想办法切换到内核空间运行（在RISC-V中，可以使用`ecall`指令切换到内核），用户程序一般使用系统调用访问内核控制的资源。内核能够检查用户请求的有效性，为用户程序请求资源；或是屏蔽有害请求，并反馈信息。

## 2.3 内核的结构

之前我们提到，操作系统需要管理硬件资源，并且实现程序之间的隔离性和共享性。操作系统自身需要有一部分安全地运行在内核空间中，而具体是哪些部分需要运行在内核中，则有许多种不同的设计。我们可以将主流的设计方案分为两种，一种是宏内核，另一种是微内核。

### 宏内核（Monolithic Kernel）

宏内核的核心设计思想就是，操作系统的所有部分（各种系统、内核服务）都运行在内核中，拥有对所有硬件资源的控制权。这种设计能够带来操作系统的高效率，不同的内核服务具有高耦合度，能够更好地进行通信、资源共享等协作。

宏内核也有其缺点，即耦合度过高带来的设计、开发复杂度的提升，这在工程上是可以预想到的。所以现代操作系统会经常推送更新，不断解决新发生的issue。

目前主流的商用操作系统，如Linux、Windows、MacOS等，都采用宏内核的设计。

### 微内核（Microkernel）

微内核的诞生就是为了解决宏内核在工程上遇到的设计和开发难题，在管理者模式下运行尽可能少的代码，并且将尽可能多的服务卸载到用户模式中。如文件系统，在一些微内核中就被编写为普通的用户程序，通过微内核和其他用户程序通信，完成服务。

微内核便于设计和实现，但同时降低了操作系统的运行效率，因为解耦带来了通信、资源共享等方面的开销。

微内核操作系统在嵌入式设备上十分热门。![21701698464766_.pic](https://raw.githubusercontent.com/Enqurance/Figures/main/202310281146620.jpg)



### 内核结构小结

总的来说，两种内核虽然在一些设计上有所不同，但是他们共享很多核心思想。譬如，两种内核都实现了系统调用、都使用页表、都处理异常、都支持进程调度等。

xv6实现了一个宏内核，尽管它十分简单，但是xv6操作系统所提供的服务的确是全部涵盖在内核当中的，这一特性决定了它是一个十分简单的宏内核。

## 进程总览

在xv6中，隔离性的最小单位是进程（在别的操作系统中可能是线程），进程级别的抽象保护了进程自身的资源、其他进程的资源和内核的资源，从而防止可能的有害程序破坏用户空间或是内核空间。为了正确、安全地实现内核的抽象，操作系统必须采取有效的策略。xv6采取了**【用户/管理者模式】、【地址空间】和【线程时间片划分】**来实现进程抽象。而对于进程所执行的程序来说，进程制造了一种假象，程序认为自己独占了机器的硬件资源并且拥有自己的地址空间。

xv6使用页表来帮助进程维护自己的地址空间。进程操作虚拟地址，而页表则能够将虚拟地址映射到物理地址，进而操作内存单元。xv6为每一个进程维护一个页表，从低地址开始，首先是存储代码的空间，随后是全局变量，然后则是运行栈，栈上面的地址空间是一个可扩展的堆区，堆区的上方则是陷阱帧和跳板段。具体参见下图：

<img src="https://raw.githubusercontent.com/Enqurance/Figures/main/202310281337909.jpg" alt="21721698471466_.pic" style="zoom:50%;" />

可以发现，进程虚拟地址的最大大小为`MAXVA`，在xv6中为$ 2^{38} − 1 = 0x3fffffffff$。RISC-V使用64位寻址空间，而硬件只使用其中的39位来寻找虚拟地址，xv6则只使用这39位中的38位。

在地址段的顶端，xv6保存了一个陷阱帧（trapframe）和跳板段（trampoline）。通过这两个区域，xv6进程可以进入内核并且返回，跳板段保存了进入和返回内核的代码，而trapframe保存了进程在切换到内核态前的状态。进程和进程的信息通过结构体`struct proc`保存（定义在`kernel/proc.h`中），其中记录了进程的页表、运行栈、运行状态等信息。

每一个进程都有一条线程来执行它的代码（指令）。内核可以通过停止当前线程的运行，并且唤起另外一个进程的线程来实现进程的切换。线程的状态存储在栈中，运行时的变量、返回值等信息存储在用户栈（运行栈）中，而进入内核后代码的运行信息则存储在内核栈中。这两个栈相互隔离，因此内核可以在不受进程运行情况的影响下处理进程。通过`ecall`指令，可以将进程切换到内核态，而通过`sret`指令可切回。

总的来说，进程是一个抽象的概念，它认为自己的地址空间和计算资源，从而让编程人员更加轻松地实现编程任务。

## xv6的启动

xv6的启动过程是一个很有意思的过程，这个过程使用了操作系统所提供的很多关键的机制。

首先，当xv6计算机启动时，会从只读存储区域中加载内核到物理地址0x80000000（0x0~0x80000000的地址短映射了外设），并且从`_entry `开始执行xv6程序，该程序在`entry.S`中，是一个汇编程序，该程序设置了一个栈，让C语言程序能够执行。在刚开机时，页表映射硬件是自动关闭的。

随后，`_entry`程序调用`start`程序，该程序在`kernel/start.c`中，它进行了一些机器模式下才能进行的配置，包括转入管理者模式、启动时间硬件等。该函数最终会调用`main`函数，在`kernel/main.c`中。

`main`函数进行设备的初始化，并且创建操作系统中的第一个进程，执行一个RISC-V系统调用。操作系统使用`a7`寄存器的值来判断需要使用哪个一系统调用。随后，该函数设置shell和IO的文件描述符，系统成功启动。

注意，这仅仅是一个简单的系统启动过程的描述，忽略了很多细节。更加具体的情况可以自行参考代码。

## 操作系统安全

操作系统需要在确保自身能够正常运行的条件下，为各种进程提供资源和服务。这意味着操作系统不仅要防止自身崩溃，也要防范来自外部程序的攻击。对于外部程序可能产生的危险行为，操作系统的设计者必须尽可能周全考虑，在设计和开发过程中防范有意或者是无意的危险行为。

与之相反的是，操作系统通常相信自身的代码和程序是正确无误的。在设计和开发时，程序员会阅读已有的文档和代码，并且撰写自己的文档和代码。

操作系统的安全是非常重要的。尽管现实生活中，情况会非常复杂，但是程序员们会尽可能设计一个安全、完备的操作系统，来为用户提供鲁棒的服务。